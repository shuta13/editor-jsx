import { ToolConstructable } from "@editorjs/editorjs";
import { createElement, Fragment } from "./create-element";
import { Props, VNode } from "./types";
import { isEditorJSVNode } from "./parser";

type RNode = {
  parent: HTMLElement | null;
  children: VNode[] | null;
  siblings: VNode[] | null;
  nodes: HTMLElement[];
};

const isWhiteSpace = (str: string) => str === " ";
const hasOwnProperty = <T = {}>(thisArg: T, key: keyof T) =>
  Object.prototype.hasOwnProperty.call(thisArg, key);

const walkNodes = (vNode: VNode, parent?: VNode): VNode | null => {
  if (hasOwnProperty(vNode, "parent") && parent) {
    vNode.parent = parent;
  }
  if (typeof vNode.type === "function") {
    const childlen = vNode.type(vNode.props);
    if (Array.isArray(childlen)) {
      for (const v of childlen) {
        return walkNodes(v, vNode);
      }
    } else if (childlen != null) {
      return walkNodes(childlen, vNode);
    } else {
      return null;
    }
  } else if (typeof vNode.type === "string" && isEditorJSVNode(vNode.type)) {
    const { children, ...pluginProps } = vNode.props;

    for (const child of children) {
      walkNodes(child, vNode);
    }

    vNode.isRoot = true;
    vNode.children = children.filter((child: VNode) =>
      hasOwnProperty(child, "type")
    );
    vNode.pluginProps = pluginProps;
    vNode.parent = null;

    return vNode;
  } else if (typeof vNode.type === "string") {
    // for HTMLElement
    const element = document.createElement(vNode.type);
    const { children, ...eventHandlers } = vNode.props;

    // check children type
    for (const child of children) {
      if (typeof child === "string" && !isWhiteSpace(child)) {
        const textVNode: VNode = {
          type: "text",
          key: undefined,
          ref: undefined,
          props: {} as unknown as Props,
          dom: document.createTextNode(child),
          original: null,
          children: null,
          component: null,
          constructor: Object.prototype.constructor,
          depth: 0,
          isRoot: false,
          hydrating: null,
          nextDom: null,
          pluginProps: null,
          parent: vNode,
        };
        if (vNode.children === null) {
          vNode.children = [textVNode];
        } else {
          vNode.children = [...vNode.children, textVNode];
        }
      } else {
        vNode.children = children.filter((child: VNode) =>
          hasOwnProperty(child, "type")
        );
        walkNodes(child, vNode);
      }
    }

    // attach event handler
    for (const [k, v] of Object.entries(eventHandlers)) {
      element.setAttribute(k.toLowerCase(), v);
    }

    vNode.dom = element;
    // append dom
    return vNode;
  }
  return vNode;
};

const createDomTree = (vNode: VNode, rNode: RNode): RNode | VNode => {
  console.log(vNode);
  if (vNode.parent) {
    const parentDom = vNode.parent.dom;
    parentDom?.appendChild(vNode.dom);
    vNode.parent.dom = parentDom;
  }
  if (vNode.children) {
    for (const child of vNode.children) {
      createDomTree(child, rNode);
    }
  }
  return rNode;
};

const normalize = (vNode: VNode) => {
  const rNode: RNode = {
    parent: null,
    children: null,
    siblings: null,
    nodes: [],
  };
  // TODO: create DOM node
  console.log(createDomTree(vNode, rNode));
  // TODO: map pluginProps to instance
  class Plugin {}
  return Plugin as unknown as ToolConstructable;
};

/**
 * @description Remove `replaceNode` from params because of using this directory as API
 */
export const createTool = (
  vNode: VNode,
  parentDom: unknown
): ToolConstructable | Error => {
  // TODO: create Editor.js plugin class as vnode
  const initialVNode = createElement(Fragment, null, vNode);

  // TODO: diff & commit
  const nodes = walkNodes(initialVNode);

  if (nodes !== null) {
    return normalize(nodes);
  }
  throw new Error();
};
